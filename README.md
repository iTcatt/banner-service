# banner_service

Тестовое задание на позицию стажер Golang разработчик. 

## Описание
Необходимо реализовать сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.


## Общие вводные
Баннер — это документ, описывающий какой-либо элемент пользовательского интерфейса. Технически баннер представляет собой  JSON-документ неопределенной структуры.  Тег — это сущность для обозначения группы пользователей; представляет собой число (ID тега).  Фича — это домен или функциональность; представляет собой число (ID фичи).

Один баннер может быть связан только с одной фичей и несколькими тегами
При этом один тег, как и одна фича, могут принадлежать разным баннерам одновременно
Фича и тег однозначно определяют баннер
Так как баннеры являются для пользователя вспомогательным функционалом, допускается, если пользователь в течение короткого срока будет получать устаревшую информацию. При этом существует часть пользователей (порядка 10%), которым обязательно получать самую актуальную информацию. Для таких пользователей нужно предусмотреть механизм получения информации напрямую из БД.

## Условия

* Тегов и фичей небольшое количество (до 1000), RPS — 1k, SLI времени ответа — 50 мс, SLI успешности ответа — 99.99%
* Для авторизации доступов должны использоваться 2 вида токенов: пользовательский и админский. Получение баннера может происходить с помощью пользовательского или админского токена, а все остальные действия могут выполняться только с помощью админского токена.  
* Реализуйте интеграционный или E2E-тест на сценарий получения баннера.
* Если при получении баннера передан флаг use_last_revision, необходимо отдавать самую актуальную информацию. В ином случае допускается передача информации, которая была актуальна 5 минут назад.
* Баннеры могут быть временно выключены. Если баннер выключен, то обычные пользователи не должны его получать, при этом админы должны иметь к нему доступ.

## Запуск сервиса
Конфиг проекта находится в папке [configs](./configs/config.yaml). Сервис запускается на 8888 порту, база данных - на 5436.
Команда для запуска:
```bash
make up
```

## Тестирование 
### Unit
TBD

### Интеграционные тесты
```bash
make e2e
```

## Вопросы и их решения

### Проектирование баз данных. 

Исходя из условия было понятно, что фичи относятся к баннерам в отношении один ко многим.
А тэги относятся к баннерам в отношении многие ко многим. С точки зрения расширяемости кода нужно было создать 4 таблицы: баннеры, теги, фичи и таблица, связывающая баннеры и теги.
Если бы для фич нужно было хранить (например) их названия или дату окончания, то я бы создал отдельную таблицу для фич. Но для упрощения работы
с БД я решил хранить id фичи внутри баннера. Однако, связь теги-баннеры я оставил и создал 3 таблицы. Хотя
это тоже можно было упростить, убрав таблицу с тегами (потому что кроме id по заданию мне больше не нужно ничего хранить)

### Авторизация и Аутентификация

Для авторизации доступов нужно было формировать два токена: админский и пользовательский.
Я решил сделать две ручки, которые будут эти токены формировать. Это будет jwt, внутри которого зашит булевый флаг,
является ли это админским токеном или нет. Это не самое лучшее решение, потому что jwt легко можно прочитать и изменить 
payload, но это все равно гораздо лучше, чем оставлять сервис без авторизации.

### Откуда брать TagID

Для меня это было самой большой загадкой. Я долго думал, как это реализовать и пришел к такому решению.
При выписывании токена, пользователю выбирается рандомный тег, на основе тех, которые есть в базе. Если база пуста, то
TagID генирируется рандомно. Таким образом, когда пользователь авторизовывается, он сразу может просматривать доступные
для него баннеры. Но когда он попытается получить баннер с чужим тегом, то получит ошибку 403.

Админ имеет TagID 0 и по умолчанию может просматривать все баннеры, а также фильтровать их. 


### Однозначное определение баннера по фиче и тегу

Чтобы обеспечить это условие, я решил перед тем как добавлять баннер, проверять не создан ли другой с таким же тегом и
фичей. Если такой уже есть, то отправляю 400 ошибку и сообщение о том, что баннер с такими TagID и FeatureID уже существует

